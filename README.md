1. 本机 IP 地址为 192.168.0.1，这可能并不重要。
2. 本机作为服务器监听 8000 端口。
3. 有多个客户端需要与本机通信，各客户端的 IP 地址配置在全局数组 g_connections 中。
4. 本机也作为客户端与远端服务器建立连接，远端服务器的地址和端口号同样配置在全局数组 g_connections 中。
5. 术语定义：
   主动连接（Active Connection）：本机作为客户端与远端服务器建立的 SOCKET 连接。
   被动连接（Passive Connection）：本机作为服务器接收的、由远端客户端发起的 SOCKET 连接。
6. 为描述每个 SOCKET 连接的信息，我定义了一个名为 Commloop 的结构体。各字段的作用在下面的注释中说明：
```cpp
struct Commloop {
    int socket;   // 套接字描述符，初始化为 -1，表示无效连接
    char ip[20];  // 远端服务器的 IP 地址
    int port;     // 远端服务器的端口号，当 as_server == 1 时该字段为 0
    int as_server;// 1 表示被动连接，0 表示主动连接
};
```
7. 定义了一个 Commloop 类型的全局数组，每条记录表示一个主动或被动连接的信息：
```cpp
Commloop g_connections[4] = {
    {-1, "192.168.0.2", 0,    1},
    {-1, "192.168.0.2", 8001, 0},
    {-1, "192.168.0.3", 0,    1},
    {-1, "192.168.0.3", 8002, 0}
};
```
8. 程序启动时扫描 g_connections 数组，若 as_server 字段为 0，则根据 ip 和 port 字段主动向远端服务器发起 SOCKET 连接。
9. 对于主动连接，当连接建立后，需根据远端 IP 且满足 as_server == 0 的条件，更新 g_connections 数组中的 socket 字段。
10. 对每个主动连接，当远端服务器断开或因异常导致连接中断时，应具有自动重连机制。
11. 对每个接收到的被动连接，应根据远端 IP 且满足 as_server == 1 的条件，更新 g_connections 数组中的 socket 字段；若远端 IP 不在 g_connections 数组中，应关闭该连接。
12. 当连接断开时，应将对应连接记录在 g_connections 数组中的 socket 字段设为 -1。
13. 发送与接收应可异步、同时进行。
14. 每条消息的前 2 个字节是当前消息长度的二进制整数。
15. 若因 SOCKET 发送缓冲区满导致消息无法一次性发送，应建立应用层缓冲机制。
16. 接收消息时需要处理“粘包”问题。
17. 从发送队列中读取数据进行发送，但发送到哪个连接暂时可不实现，我会根据数据内容再决定。
